= Moving around
:stylesdir: css
:stylesheet: style.css
:imagesdir: images
:scriptsdir: javascript
:linkcss:

Working a whole day on the same line in the same file is a relatively uncommon pattern. In reality, we spend a lot of time jumping from one word to another, one line to another, one function to another, one file to another or even one area of the project to another. For years, editor developers have come up with various ways to make those movements easier and Vim has arguably been ahead of the curve for most of its long history.

This chapter tries to present an exhaustive panorama of the many [...]

== Starting small

== Moving within a buffer

Contrary to common belief, `hjkl` are far from being the be-all and end-all of text editing. Using them to replace the arrows _may_ make some sense but the gain will be negligible if you only use them. `hjkl` are unfortunately the Vim equivalent of a rachitic tree hiding a lush forest. A forest so rich you will wonder why you wasted so much energy on that ugly little excuse of a tree.

Moving the cursor character-by-character and line-by-line is perfectly OK as long as we are talking about local movement. And by "`local`" I mean "`hyperlocal`". The usefulness of that method, whether it involves the famous `hjkl`, `wasd` or the arrows, diminishes quickly as we augment the distance. That is why most "`normal`" editors allow us to do things like Alt+Right or Ctrl+Up to jump over whole words or paragraphs and why Vim allows us to do that… and a lot more.

=== Motions

Starting small, we have _word-level_ motions:

[cols="1,9"]
|===
|`w`|jump to first character of next _word_
|`b`|jump to first character of current _word_ or first character of previous _word_ if already on first character of current _word_
|`e`|jump to last character of current _word_ or last character of next _word_ if already on last character of current _word_
|`ge`|jump to last character of previous _word_
|===

Did you notice how I emphasized the word "`word`"? That's because we have this very useful distinction between a "`word`", delimited by non-keyword characters, and a "`WORD`", delimited by white space:

....
             ┌─────────────────────────────── a word
             │┌───────┬────────────────────── another word
             ││       │┌───────────────────── and another word
We live in a "wonderful" world.
             └─────────┴───────────────────── a WORD
....

This gives us the following variants of the motions above:

[cols="1,9"]
|===
|`W`|jump to first character of next _WORD_
|`B`|jump to first character of current _WORD_ or first character of previous _WORD_ if already on first character of current _WORD_
|`E`|jump to last character of current _WORD_ or last character of next _WORD_ if already on last character of current _WORD_
|`gE`|jump to last character of previous _WORD_
|===

Those word-level motions alone cover more ground than our usual Ctrl+Arrow and let us avoid an enormous amount of mindless arrowing _and_ `hjkl`-ing.

Approximation vs precision.

Zooming out a little, we have a bunch of generic _line-level_ motions:

[cols="1,9"]
|===
|`0`|jump to first column
|`^`|jump to first printable character
|`$`|jump to EOL
|`g_`|jump to last printable character
|`g^`|jump to first displayed character
|`g$`|jump to last displayed character
|===

and another bunch of what I would call "`dynamic`" motions:

[cols="1,9"]
|===
|`fx`|jump to next character `x`
|`Fx`|jump to previous character `x`
|`tx`|jump before next character `x`
|`Tx`|jump before previous character `x`
|===

The first set of motions above have very strict meanings: there's only one EOL on the current line, or one last printable character. That kind of motion always works the same way.

The motions in the second set are a bit different.

First, because the second character -- `x` in our example -- can be any character, meaning that those four commands can be used to jump to a very large amount of potential targets.

Second, because they can take an optional `[count]` to jump to the `[count]`-th character on the line: `3fn` for "`jump to the third `n` to the right`".

Third, because they can be repeated with `;` (in the same direction) and `,` (in the opposite direction).

Zooming out a bit more, we have another set of useful motions:

[cols="1,9"]
|===
|`)`|jump to next sentence
|`(`|jump to previous sentence
|`}`|jump to next blank line-separated
|`{`|jump to previous blank line
|===

etc




=== Search

=== Defines

== Moving within a project

=== Files

=== Grep

=== Includes/Defines

=== Tags

== Search-based navigation

Searching is a wonderful way to navigate the current buffer. Together with `:set incsearch`, `/` and `?` rarely need more than 4 or 5 keystrokes to get us where we need to.

(gif)

    /foo<CR>          " search forward for foo
    ?bar<CR>          " search backward for bar
    n                 " repeat the last search
    N                 " repeat the last search in the opposite direction

These few options are generally considered useful:

* `:help 'incsearch'` moves the cursor to — and highlights — the next match *as you type*.
* `:help 'ignorecase'` makes search case-insensitive; allows you to reach `Foo` with `foo`.
* `:help 'smartcase'` turns case-sensitivity on if the search pattern contains an uppercase letter. `/Foo` skips `foo` on the way to `Foo`.
* `:help 'hlsearch'` highlights *every* match, in every visible window.
* `:help :nohl` turns off `'hlsearch'`'s highlighting until next search.

== Search inside the current buffer

    :g/foo/#

== Search inside the current buffer, and included files, excluding comments

While `/` and `#` are awesome *navigation* tools, they are not that good for *actual* searching. "Searching" usually involves comparing matches, filtering… all things `/` and `?` actually make quite hard, if only because we can't see all the matches at once.

But Vim has got our back with `:help :ilist`:

* List every line containing the whole word `foo` and jump to one of them:

    :il foo<CR>:202<CR> (gif)

* List every line containing `foo`

    :il /foo<CR> (gif)

* Create a TOC of the current markdown document

    :il /#<CR> (gif)

… and its more specialized sibling `:help :dlist`:

* List every function containing `bar` in its name

    :dli bar<CR>

* List every function

    :dli /<CR>

=== … and replace

* List all the functions containing `user` and add a TODO item above one of them 

    :dli /user<CR>:1034norm O// TODO: fix this function<CR> (gif)

* List all the occurences of `myVar` and substitute only some of them with `myArray`

    :il myVar<CR>:53,89s/myVar/myArray (gif)

== Search inside loaded buffers

    :call setqflist([])<CR>
    :bufdo vimgrepadd foo % | cw
    
    :command! -nargs=1 SearchInBuffers call setqflist([])|silent! bufdo vimgrepadd <args> %|cw

=== And replace

    

== Search recursively inside project

=== … and replace

