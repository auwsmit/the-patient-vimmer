= Your workspace
:stylesdir: css
:stylesheet: style.css
:imagesdir: images
:scriptsdir: javascript
:linkcss:

TODO (texte d'intro)

== Buffers

Like Word or Photoshop, Vim lets us create, delete and -- of course -- edit "`documents`", whether they are associated to an actual file or not. Those documents are called "`buffers`".

A buffer is the internal representation of the content of a file. Because you work on a representation of that file, your changes will not be written to the corresponding file unless you instruct Vim to do so with `:write` or `:update`.

As Vim's core file proxies, buffers are (or should be) at the core of your workflow and you owe it to yourself to know how to work with them to achieve reasonable efficiency.

=== The buffer list

Every buffer created in Vim via `:edit`, `:find`, `:args`, any of their relatives or simply `$ vim filename` is added to the _buffer list_ where it is assigned a number that will never change until it is explicitely wiped out from the list. Beside that number, a buffer associated with a file will be named after that file, giving us a second way to address that buffer.

A typical Vim session could be short and only consist of editing a single file -- and thus a single buffer -- or it could go for weeks and consist of dozens and dozens of buffers. Keeping track of so many buffers would be daunting if Vim didn't gave us not one, not two, but _three_ commands for listing buffers:

    :buffers
    :files
    :ls

All those commands do the same thing so we will simply use the shortest: `:ls`. Here is what its output looks like:

      1  h   "foo.txt"                      line 1
      2 #h   "bar.txt"                      line 1
      3 %a   "baz.txt"                      line 1
    Press ENTER or type command to continue

* The first column shows the buffer number.

* The second column gives us information on the state of the buffer, `h` means "`hidden`", `a` means "`active`", `%` marks the current buffer and `#` marks the "`alternate file`", which I usually think of as "`previous buffer`".

* The third column tells us the buffer name.

* And the last column shows the current position of the cursor.

No cursor, no active line, no selectionâ€¦ obviously, this list is not nicely interactive so what good is it? Well, the last line gives us a couple of hints: pressing `ENTER` unsurprisingly makes the list go away but we can also press `:` to enter command-line mode and use an Ex command to do something with the info we get from the list.

Buffers come with _a lot_ of navigation and management commands, let's see a few things we can do with the list above:

    :b1      " jump to buffer number 1
    :b#      " jump back to the previous buffer
    :bd 2    " delete buffer number 2

Unlike some other more "`modern`" editors, Vim doesn't have a built-in way of displaying a permanent list of loaded buffers. This may feel like a limitation if you are used to that feature but think about it for a moment... do you _really_ need that list when you are not trying to jump to another buffer?

Of course, it is not necessary to do `:ls` before doing `:b24` but who wants to keep a list of buffers updated in his head? Well... I certainly don't.

One way to avoid thinking too much about your buffers is to mash `:bn[ext]` and `:bp[revious]` until you get where you want. Your destination might be sixteen buffers away, though, so cycling is not a silver bullet.

But that boring `:ls`, then `<CR>`, then `:b`, then `24`, then `<CR>`, routine looks like a good candidate for a custom mapping:

    nnoremap <leader>b :ls<CR>:b

Here is how it looks:

    (gifcast)

=== Working with buffers

== Windows

(intro)

=== The life cycle of a window

=== Working with windows

== Tab pages

(intro)

=== The life cycle of a tab page

=== Working with tab pages

== Special Windows

(intro)

=== The quickfix window

The quickfix is a handy list that we can populate and navigate at will. It actually is a bit more complicated but the quickfix list can be thought of as a list containing a number of entries made of:

* a filename,
* a line number,
* an optional column number,
* some text associated with the current item.

That list is global. This means that you can't have more than one active list at a time. One could recall previous lists with `:colder` but I honestly never had to so... YMMV.

Vim comes with a bunch of commands that populate the quickfix list like `:grep` or `:vimgrep`, used for searching text in your project, and `:make`, used to build your program or pass them through a syntax checker. Once the quickfix is populated with valid entries, one can use a number of relatively intitively named commands to navigate the list:

    :cfirst
    :clast
    :cnext
    :cprevious

or use `:copen` -- or the slightly smarter `:cwindow` -- to open the interactive "`quickfix window`":

    (gifcast)

See? The quickfix window is super-useful and super-easy to use.

The quickfix list has a close cousin called "`location list`" that pretty much works the same way except for these two differences:

* unlike the quickfix list, the location list is local to a window so you can have as many as you have windows,
* the commands start with an `l` instead of a `c`, `:lfirst`, `:lwindow`, etc.

Using the location list can be useful if you are heavily into windows and tab pages but the quickfix list is probably a simpler choice otherwise.

Now, repeating the `:w` & `:mak` & `:cw` dance over and over doesn't sound fun. Does it? Well, those commands can be chained with a `|`:

    :w|mak|cw

and recalled with `<Up>` so that's not big of a deal but there is still room for improvement, here, because:

* we have too many `<Enter>` to press,
* some kind of automation would be better.

Let's address the first issue by telling Vim to shut up with the `:silent` command:

    :w|silent mak|cw

And take advantage of a great feature called "`autocommands`" for... the automation part.

Autocommands are Vim's way of executing arbitrary commands when specific events happen. Entering a window, quitting insert mode, loading a buffer with a specific filetype are some of the many events available.

An autocommand usually looks like that:

    autocmd event pattern command

where `autocmd` is the command that defines an autocommand, `event` can be a single event or a comma-separated list of events, `pattern` is a simple pattern describing what [todo] and `command` is what we want to happen.

Scrolling through the list at `:help autocommand-events` we find `BufWritePost` which looks like it can be used after `:w` to `:make` and `:cwindow`. Let's try it:

    autocmd BufWritePost *.c silent make|cwindow

Phew! That was easy...

==== Reference

=== The preview window

=== The Command-line window

== Various UI elements

=== The tabline

=== The statusline

=== Line numbers

=== The foldcolumn

=== The signcolumn

=== The completion menu

=== The command-line
