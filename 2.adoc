= Your workspace
:stylesdir: css
:stylesheet: style.css
:imagesdir: images
:scriptsdir: javascript
:linkcss:

TODO (texte d'intro)

== Buffers

Like Word or Photoshop, Vim lets us create, delete and -- of course -- edit "`documents`", whether they are associated to an actual file or not. Those documents are called "`buffers`".

A buffer is the internal representation of the content of a file. Because you work on a representation of that file, your changes will not be written to the corresponding file unless you instruct Vim to do so with `:write` or `:update`.

As Vim's core file proxies, buffers are (or should be) at the core of your workflow and you owe it to yourself to know how to work with them to achieve reasonable efficiency.

=== The buffer list

Every buffer created in Vim via `:edit`, `:find`, `:args`, any of their relatives or simply `$ vim filename` is added to the _buffer list_ where it is assigned a number that will never change until it is explicitely wiped out from the list. Beside that number, a buffer associated with a file will be named after that file, giving us a second way to address that buffer.

A typical Vim session could be short and only consist of editing a single file -- and thus a single buffer -- or it could go for weeks and consist of dozens and dozens of buffers. Keeping track of so many buffers would be daunting if Vim didn't gave us not one, not two, but _three_ commands for listing buffers:

    :buffers
    :files
    :ls

All those commands do the same thing so we will simply use the shortest: `:ls`. Here is what its output looks like:

      1  h   "foo.txt"                      line 1
      2 #h   "bar.txt"                      line 1
      3 %a   "baz.txt"                      line 1
    Press ENTER or type command to continue

* The first column shows the buffer number.

* The second column gives us information on the state of the buffer, `h` means "`hidden`", `a` means "`active`", `%` marks the current buffer and `#` marks the "`alternate file`", which I usually think of as "`previous buffer`".

* The third column tells us the buffer name.

* And the last column shows the current position of the cursor.

No cursor, no active line, no selectionâ€¦ obviously, this list is not nicely interactive so what good is it? Well, the last line gives us a couple of hints: pressing `ENTER` unsurprisingly makes the list go away but we can also press `:` to enter command-line mode and use an Ex command to do something with the info we get from the list.

Buffers come with _a lot_ of navigation and management commands, let's see a few things we can do with the list above:

    :b1      " jump to buffer number 1
    :b#      " jump back to the previous buffer
    :bd 2    " delete buffer number 2

Unlike some other more "`modern`" editors, Vim doesn't have a built-in way of displaying a permanent list of loaded buffers. This may feel like a limitation if you are used to that feature but think about it for a moment... do you _really_ need that list when you are not trying to jump to another buffer?

Of course, it is not necessary to do `:ls` before doing `:b24` but who wants to keep a list of buffers updated in his head? Well... I certainly don't.

One way to avoid thinking too much about your buffers is to mash `:bn[ext]` and `:bp[revious]` until you get where you want. Your destination might be sixteen buffers away, though, so cycling is not a silver bullet.

But that boring `:ls`, then `<CR>`, then `:b`, then `24`, then `<CR>`, routine looks like a good candidate for a custom mapping:

    nnoremap <leader>b :ls<CR>:b

Here is how it looks:

    (gifcast)

=== Working with buffers

== Windows

(intro)

=== The life cycle of a window

=== Working with windows

== Tab pages

(intro)

=== The life cycle of a tab page

=== Working with tab pages

== Special Windows

Beyond normal windows, Vim uses a number of very useful specialized windows.

=== The quickfix window

The quickfix is a handy list that we can populate and navigate at will. It actually is a bit more complicated but the quickfix list can be thought of as a list containing a number of entries made of:

* a filename,
* a line number,
* an optional column number,
* some text associated with the current item.

That list is global. This means that you can't have more than one active list at a time. One could recall previous lists with `:colder` but I honestly never had to so... YMMV.

Vim comes with a bunch of commands that populate the quickfix list like `:grep` or `:vimgrep`, used for searching text in your project, and `:make`, used to build your program or pass them through a syntax checker. Once the quickfix is populated with valid entries, one can use a number of relatively intitively named commands to navigate the list:

    :cfirst
    :clast
    :cnext
    :cprevious

or use `:copen` -- or the slightly smarter `:cwindow` -- to open the interactive "`quickfix window`":

    (gifcast)

See? The quickfix window is super-useful and super-easy to use.

The quickfix list has a close cousin called "`location list`" that pretty much works the same way except for these two differences:

* unlike the quickfix list, the location list is local to a window so you can have as many as you have windows,
* the commands start with an `l` instead of a `c`, `:lfirst`, `:lwindow`, etc.

Using the location list can be useful if you are heavily into windows and tab pages but the quickfix list is probably a simpler choice otherwise.

Now, repeating the `:w` & `:mak` & `:cw` dance over and over doesn't sound fun. Does it? Well, those commands can be chained with a `|`:

    :w|mak|cw

and recalled with `<Up>` so that's not big of a deal but there is still room for improvement, here, because:

* we have too many `<Enter>` to press,
* some kind of automation would be better.

Let's address the first issue by telling Vim to shut up with the `:silent` command:

    :w|silent mak|cw

And take advantage of a great feature called "`autocommands`" for... the automation part.

Autocommands are Vim's way of executing arbitrary commands when specific events happen. Entering a window, quitting insert mode, loading a buffer with a specific filetype are some of the many events available.

An autocommand usually looks like that:

    autocmd event pattern command

where `autocmd` is the command that defines an autocommand, `event` can be a single event or a comma-separated list of events, `pattern` is a simple pattern describing what [todo] and `command` is what we want to happen.

Scrolling through the list at `:help autocommand-events` we find `BufWritePost` which looks like it can be used after `:w` to `:make` and `:cwindow`. Let's try it:

    autocmd BufWritePost *.c silent make|cwindow

Phew! That was easy...

From there, one can configure many things to suit his needs: what program to run when doing `:make` or `:grep`, how to parse the output of those comands so that it can be used in the quickfix list, for what filetype to use what setting...

==== Reference

    :help quickfix
    :help autocommand
    :help :silent

=== The preview window

The preview window is a small window used to preview something, usually the signature of a function while we are working on its usage. It is a lot like a normal window except for these differences:

* opening the preview window doesn't steal the focus from the current window,
* it can be closed even if it is not focused.

This window can be opened with a bunch of commands, among which these ones:

    :ptag foo       " open tag 'foo' in a preview window
    <C-w>}          " open tag under the cursor in a preview window
    :psearch bar    " use include search to find 'bar' and open it in a preview window

And closed with: `:pclose` or `<C-w>z`.

Here is the preview window in action:

    (gifcast)

==== Reference

    :help preview-window

=== The Command-line window

The command-line is a handy way to input commands but it is not that good when it comes to editing the current command or recalling an old one and changing its parameters. This is, in my opinion, not a design flaw or an implementation issue: only a sane seperation of concerns that should appeal to anyone used to the concept of *modal editing*.

You use insert mode to insert text and normal mode to edit text.

You use command-line mode to issue commands and the command-line window to edit the current command and command history.

Simple.

Opening the command-line window from the current command-line mode is done with `<C-f>`. This will open the relevant command history in the command-line window, with the current command ready for you to edit on the last line.

From normal mode, you can use `q:` to open the command-line history or `q/`/`q?` to open the search history. Press `<CR>` in normal mode to run the current command or `:q` to quit that window.

Here is the command-line window in action:

    (gifcast)

Some hardcore Ex commands users like to use the command-line window instead of the usual command-line. This can be done by overriding `:` in normal mode:

    nnoremap : q:i

I don't recommend doing that, actually, but I think it is an interesting example of customization.

==== Reference

    :h cmdline-window

== Various UI elements

In addition to windows, we have many UI elements at our disposal for displaying information and/or interacting with one feature or another.

=== The tabline

   (picture)

The tabline is used to display a list of tabs, each associated with a tab page and showing some information and a "Close" button -- the `X` at the end -- for the current tab page. The number of windows contained in each tab page is indicated whenever there is more than one and a `+` is added whenever one of the buffers displayed in one of the windows is "dirty".

If you have enabled mouse support in your `vimrc` and your terminal emulator supports that feature, you can use your mouse to switch to a tab page, reorder the tabs or close the current tab page by clicking on the `X` at the end of the tabline.

When to show a tabline can be defined with the `showtabline` option and what information to display depends on the `tabline` option.

While Vim's _tab pages_ are definitely not equivalent to other editor's _tabs_, Vim's _tabline_ looks and works a lot like its counterparts and suffers from the same usability issues.

The main issue is that tabs are used to display filenames and filenames take up a lot of horizontal space. An horizontal space that is physically limited and thus incapable of displaying more than a few tabs. Many solutions exist to remedy that problem: wrapping the tabline to form a second one, adding scrolling widgets at both ends of the tabline, grouping tabs, truncating filenames... The harsh reality is that none of those "solutions" is free of annoying side effects which, ultimately, turn an otherwise good idea into an unusable gyzmo.

The tabline and tab pages still have their use, mind you, but it is important to not think about them as you would in other editors.

==== Reference

    :help 'showtabline'
    :help 'tabline'
    :help setting-tabline

=== The statusline

    (picture)

The statusline is that "bar", at the bottom of windows, used to show informations on the window itself or the buffer currently displayed in that window. It can also be used to resize windows if mouse support is enabled.

By default, the statusline is shown only when there is more than one window but it can be changed with the `laststatus` option.

The default content of the statusline -- the filename and a status indicator -- is not exactly thrilling but it's possible to beef it up by enabling the `ruler` option that shows the line and colum of the cursor and tells how much of the buffer is currently visible.

It is very common, though, to customize it a bit further by playing with the `statusline` option that gives more control over the statusline's content and appearance.

This is how I define the statusline shown in the picture above:

    set statusline=%<\ %f\ %m%r%y%w%=\ L:\ \%l\/\%L\ C:\ \%c\ 

It is also possible to define colors for specific parts but I'd recommend measure, here: the statusline is an information device, not a decorative apparatus.

==== Reference

    :help 'statusline'
    :help 'laststatus'
    :help 'ruler'

=== Line numbers

=== The foldcolumn

=== The signcolumn

=== The completion menu

=== The command-line
