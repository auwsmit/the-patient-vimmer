<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Your workspace</title>
<link rel="stylesheet" href="css/style.css">
</head>
<body class="article">
<div id="header">
<h1>Your workspace</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>TODO (texte d&#8217;intro)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buffers">Buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like Word or Photoshop, Vim lets us create, delete and&#8201;&#8212;&#8201;of course&#8201;&#8212;&#8201;edit &#8220;documents&#8221;, whether they are associated to an actual file or not. Those documents are called &#8220;buffers&#8221;.</p>
</div>
<div class="paragraph">
<p>A buffer is the internal representation of the content of a file. Because you work on a representation of that file, your changes will not be written to the corresponding file unless you instruct Vim to do so with <code>:write</code> or <code>:update</code>.</p>
</div>
<div class="paragraph">
<p>As Vim&#8217;s core file proxies, buffers are (or should be) at the core of your workflow and you owe it to yourself to know how to work with them to achieve reasonable efficiency.</p>
</div>
<div class="sect2">
<h3 id="_the_buffer_list">The buffer list</h3>
<div class="paragraph">
<p>Every buffer created in Vim via <code>:edit</code>, <code>:find</code>, <code>:args</code>, any of their relatives or simply <code>$ vim filename</code> is added to the <em>buffer list</em> where it is assigned a number that will never change until it is explicitely wiped out from the list. Beside that number, a buffer associated with a file will be named after that file, giving us a second way to address that buffer.</p>
</div>
<div class="paragraph">
<p>A typical Vim session could be short and only consist of editing a single file&#8201;&#8212;&#8201;and thus a single buffer&#8201;&#8212;&#8201;or it could go for weeks and consist of dozens and dozens of buffers. Keeping track of so many buffers would be daunting if Vim didn&#8217;t gave us not one, not two, but <em>three</em> commands for listing buffers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:buffers
:files
:ls</pre>
</div>
</div>
<div class="paragraph">
<p>All those commands do the same thing so we will simply use the shortest: <code>:ls</code>. Here is what its output looks like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  1  h   "foo.txt"                      line 1
  2 #h   "bar.txt"                      line 1
  3 %a   "baz.txt"                      line 1
Press ENTER or type command to continue</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The first column shows the buffer number.</p>
</li>
<li>
<p>The second column gives us information on the state of the buffer, <code>h</code> means &#8220;hidden&#8221;, <code>a</code> means &#8220;active&#8221;, <code>%</code> marks the current buffer and <code>#</code> marks the &#8220;alternate file&#8221;, which I usually think of as &#8220;previous buffer&#8221;.</p>
</li>
<li>
<p>The third column tells us the buffer name.</p>
</li>
<li>
<p>And the last column shows the current position of the cursor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No cursor, no active line, no selectionâ€¦ obviously, this list is not nicely interactive so what good is it? Well, the last line gives us a couple of hints: pressing <code>ENTER</code> unsurprisingly makes the list go away but we can also press <code>:</code> to enter command-line mode and use an Ex command to do something with the info we get from the list.</p>
</div>
<div class="paragraph">
<p>Buffers come with <em>a lot</em> of navigation and management commands, let&#8217;s see a few things we can do with the list above:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:b1      " jump to buffer number 1
:b#      " jump back to the previous buffer
:bd 2    " delete buffer number 2</pre>
</div>
</div>
<div class="paragraph">
<p>Unlike some other more &#8220;modern&#8221; editors, Vim doesn&#8217;t have a built-in way of displaying a permanent list of loaded buffers. This may feel like a limitation if you are used to that feature but think about it for a moment&#8230;&#8203; do you <em>really</em> need that list when you are not trying to jump to another buffer?</p>
</div>
<div class="paragraph">
<p>Of course, it is not necessary to do <code>:ls</code> before doing <code>:b24</code> but who wants to keep a list of buffers updated in his head? Well&#8230;&#8203; I certainly don&#8217;t.</p>
</div>
<div class="paragraph">
<p>One way to avoid thinking too much about your buffers is to mash <code>:bn[ext]</code> and <code>:bp[revious]</code> until you get where you want. Your destination might be sixteen buffers away, though, so cycling is not a silver bullet.</p>
</div>
<div class="paragraph">
<p>But that boring <code>:ls</code>, then <code>&lt;CR&gt;</code>, then <code>:b</code>, then <code>24</code>, then <code>&lt;CR&gt;</code>, routine looks like a good candidate for a custom mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap &lt;leader&gt;b :ls&lt;CR&gt;:b</pre>
</div>
</div>
<div class="paragraph">
<p>Here is how it looks:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_buffers">Working with buffers</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_windows">Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(intro)</p>
</div>
<div class="sect2">
<h3 id="_the_life_cycle_of_a_window">The life cycle of a window</h3>

</div>
<div class="sect2">
<h3 id="_working_with_windows">Working with windows</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_tab_pages">Tab pages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(intro)</p>
</div>
<div class="sect2">
<h3 id="_the_life_cycle_of_a_tab_page">The life cycle of a tab page</h3>

</div>
<div class="sect2">
<h3 id="_working_with_tab_pages">Working with tab pages</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_special_windows">Special Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Beyond normal windows, Vim uses a number of very useful specialized windows.</p>
</div>
<div class="sect2">
<h3 id="_the_quickfix_window">The quickfix window</h3>
<div class="paragraph">
<p>The quickfix is a handy list that we can populate and navigate at will. It actually is a bit more complicated but the quickfix list can be thought of as a list containing a number of entries made of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a filename,</p>
</li>
<li>
<p>a line number,</p>
</li>
<li>
<p>an optional column number,</p>
</li>
<li>
<p>some text associated with the current item.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That list is global. This means that you can&#8217;t have more than one active list at a time. One could recall previous lists with <code>:colder</code> but I honestly never had to so&#8230;&#8203; YMMV.</p>
</div>
<div class="paragraph">
<p>Vim comes with a bunch of commands that populate the quickfix list like <code>:grep</code> or <code>:vimgrep</code>, used for searching text in your project, and <code>:make</code>, used to build your program or pass them through a syntax checker. Once the quickfix is populated with valid entries, one can use a number of relatively intitively named commands to navigate the list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cfirst
:clast
:cnext
:cprevious</pre>
</div>
</div>
<div class="paragraph">
<p>or use <code>:copen</code>&#8201;&#8212;&#8201;or the slightly smarter <code>:cwindow</code>&#8201;&#8212;&#8201;to open the interactive &#8220;quickfix window&#8221;:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>See? The quickfix window is super-useful and super-easy to use.</p>
</div>
<div class="paragraph">
<p>The quickfix list has a close cousin called &#8220;location list&#8221; that pretty much works the same way except for these two differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>unlike the quickfix list, the location list is local to a window so you can have as many as you have windows,</p>
</li>
<li>
<p>the commands start with an <code>l</code> instead of a <code>c</code>, <code>:lfirst</code>, <code>:lwindow</code>, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using the location list can be useful if you are heavily into windows and tab pages but the quickfix list is probably a simpler choice otherwise.</p>
</div>
<div class="paragraph">
<p>Now, repeating the <code>:w</code> &amp; <code>:mak</code> &amp; <code>:cw</code> dance over and over doesn&#8217;t sound fun. Does it? Well, those commands can be chained with a <code>|</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:w|mak|cw</pre>
</div>
</div>
<div class="paragraph">
<p>and recalled with <code>&lt;Up&gt;</code> so that&#8217;s not big of a deal but there is still room for improvement, here, because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we have too many <code>&lt;Enter&gt;</code> to press,</p>
</li>
<li>
<p>some kind of automation would be better.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s address the first issue by telling Vim to shut up with the <code>:silent</code> command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:w|silent mak|cw</pre>
</div>
</div>
<div class="paragraph">
<p>And take advantage of a great feature called &#8220;autocommands&#8221; for&#8230;&#8203; the automation part.</p>
</div>
<div class="paragraph">
<p>Autocommands are Vim&#8217;s way of executing arbitrary commands when specific events happen. Entering a window, quitting insert mode, loading a buffer with a specific filetype are some of the many events available.</p>
</div>
<div class="paragraph">
<p>An autocommand usually looks like that:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>autocmd event pattern command</pre>
</div>
</div>
<div class="paragraph">
<p>where <code>autocmd</code> is the command that defines an autocommand, <code>event</code> can be a single event or a comma-separated list of events, <code>pattern</code> is a simple pattern describing what [todo] and <code>command</code> is what we want to happen.</p>
</div>
<div class="paragraph">
<p>Scrolling through the list at <code>:help autocommand-events</code> we find <code>BufWritePost</code> which looks like it can be used after <code>:w</code> to <code>:make</code> and <code>:cwindow</code>. Let&#8217;s try it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>autocmd BufWritePost *.c silent make|cwindow</pre>
</div>
</div>
<div class="paragraph">
<p>Phew! That was easy&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>From there, one can configure many things to suit his needs: what program to run when doing <code>:make</code> or <code>:grep</code>, how to parse the output of those comands so that it can be used in the quickfix list, for what filetype to use what setting&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_reference">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help quickfix
:help autocommand
:help :silent</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_preview_window">The preview window</h3>
<div class="paragraph">
<p>The preview window is a small window used to preview something, usually the signature of a function while we are working on its usage. It is a lot like a normal window except for these differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>opening the preview window doesn&#8217;t steal the focus from the current window,</p>
</li>
<li>
<p>it can be closed even if it is not focused.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This window can be opened with a bunch of commands, among which these ones:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:ptag foo       " open tag 'foo' in a preview window
&lt;C-w&gt;}          " open tag under the cursor in a preview window
:psearch bar    " use include search to find 'bar' and open it in a preview window</pre>
</div>
</div>
<div class="paragraph">
<p>And closed with: <code>:pclose</code> or <code>&lt;C-w&gt;z</code>.</p>
</div>
<div class="paragraph">
<p>Here is the preview window in action:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_reference_2">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help preview-window</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_command_line_window">The Command-line window</h3>
<div class="paragraph">
<p>The command-line is a handy way to input commands but it is not that good when it comes to editing the current command or recalling an old one and changing its parameters. This is, in my opinion, not a design flaw or an implementation issue: only a sane seperation of concerns that should appeal to anyone used to the concept of <strong>modal editing</strong>.</p>
</div>
<div class="paragraph">
<p>You use insert mode to insert text and normal mode to edit text.</p>
</div>
<div class="paragraph">
<p>You use command-line mode to issue commands and the command-line window to edit the current command and command history.</p>
</div>
<div class="paragraph">
<p>Simple.</p>
</div>
<div class="paragraph">
<p>Opening the command-line window from the current command-line mode is done with <code>&lt;C-f&gt;</code>. This will open the relevant command history in the command-line window, with the current command ready for you to edit on the last line.</p>
</div>
<div class="paragraph">
<p>From normal mode, you can use <code>q:</code> to open the command-line history or <code>q/</code>/<code>q?</code> to open the search history. Press <code>&lt;CR&gt;</code> in normal mode to run the current command or <code>:q</code> to quit that window.</p>
</div>
<div class="paragraph">
<p>Here is the command-line window in action:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>Some hardcore Ex commands users like to use the command-line window instead of the usual command-line. This can be done by overriding <code>:</code> in normal mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap : q:i</pre>
</div>
</div>
<div class="paragraph">
<p>I don&#8217;t recommend doing that, actually, but I think it is an interesting example of customization.</p>
</div>
<div class="sect3">
<h4 id="_reference_3">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:h cmdline-window</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_various_ui_elements">Various UI elements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to windows, we have many UI elements at our disposal for displaying information and/or interacting with one feature or another.</p>
</div>
<div class="sect2">
<h3 id="_the_tabline">The tabline</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The tabline is used to display a list of tabs, each associated with a tab page and showing some information and a "Close" button&#8201;&#8212;&#8201;the <code>X</code> at the end&#8201;&#8212;&#8201;for the current tab page. The number of windows contained in each tab page is indicated whenever there is more than one and a <code>+</code> is added whenever one of the buffers displayed in one of the windows is "dirty".</p>
</div>
<div class="paragraph">
<p>If you have enabled mouse support in your <code>vimrc</code> and your terminal emulator supports that feature, you can use your mouse to switch to a tab page, reorder the tabs or close the current tab page by clicking on the <code>X</code> at the end of the tabline.</p>
</div>
<div class="paragraph">
<p>When to show a tabline can be defined with the <code>showtabline</code> option and what information to display depends on the <code>tabline</code> option.</p>
</div>
<div class="paragraph">
<p>While Vim&#8217;s <em>tab pages</em> are definitely not equivalent to other editor&#8217;s <em>tabs</em>, Vim&#8217;s <em>tabline</em> looks and works a lot like its counterparts and suffers from the same usability issues.</p>
</div>
<div class="paragraph">
<p>The main issue is that tabs are used to display filenames and filenames take up a lot of horizontal space. An horizontal space that is physically limited and thus incapable of displaying more than a few tabs. Many solutions exist to remedy that problem: wrapping the tabline to form a second one, adding scrolling widgets at both ends of the tabline, grouping tabs, truncating filenames&#8230;&#8203; The harsh reality is that none of those "solutions" is free of annoying side effects which, ultimately, turn an otherwise good idea into an unusable gyzmo.</p>
</div>
<div class="paragraph">
<p>The tabline and tab pages still have their use, mind you, but it is important to not think about them as you would in other editors.</p>
</div>
<div class="sect3">
<h4 id="_reference_4">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help 'showtabline'
:help 'tabline'
:help setting-tabline</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_statusline">The statusline</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The statusline is that "bar", at the bottom of windows, used to show informations on the window itself or the buffer currently displayed in that window. It can also be used to resize windows if mouse support is enabled.</p>
</div>
<div class="paragraph">
<p>By default, the statusline is shown only when there is more than one window but it can be changed with the <code>laststatus</code> option.</p>
</div>
<div class="paragraph">
<p>The default content of the statusline&#8201;&#8212;&#8201;the filename and a status indicator&#8201;&#8212;&#8201;is not exactly thrilling but it&#8217;s possible to beef it up by enabling the <code>ruler</code> option that shows the line and colum of the cursor and tells how much of the buffer is currently visible.</p>
</div>
<div class="paragraph">
<p>It is very common, though, to customize it a bit further by playing with the <code>statusline</code> option that gives more control over the statusline&#8217;s content and appearance.</p>
</div>
<div class="paragraph">
<p>This is how I define the statusline shown in the picture above:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set statusline=%&lt;\ %f\ %m%r%y%w%=\ L:\ \%l\/\%L\ C:\ \%c\</pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to define colors for specific parts but I&#8217;d recommend measure, here: the statusline is an information device, not a decorative apparatus.</p>
</div>
<div class="sect3">
<h4 id="_reference_5">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help 'statusline'
:help 'laststatus'
:help 'ruler'</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_line_numbers">Line numbers</h3>

</div>
<div class="sect2">
<h3 id="_the_foldcolumn">The foldcolumn</h3>

</div>
<div class="sect2">
<h3 id="_the_signcolumn">The signcolumn</h3>

</div>
<div class="sect2">
<h3 id="_the_completion_menu">The completion menu</h3>

</div>
<div class="sect2">
<h3 id="_the_command_line">The command-line</h3>

</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-03-29 21:40:12 CEST
</div>
</div>
</body>
</html>