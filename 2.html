<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Your workspace</title>
<link rel="stylesheet" href="css/style.css">
</head>
<body class="article">
<div id="header">
<h1>Your workspace</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>TODO (texte d&#8217;intro)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buffers">Buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like Word or Photoshop, Vim lets us create, delete and&#8201;&#8212;&#8201;of course&#8201;&#8212;&#8201;edit &#8220;documents&#8221;, whether they are associated to an actual file or not. Those documents are called &#8220;buffers&#8221;.</p>
</div>
<div class="paragraph">
<p>A buffer is the internal representation of the content of a file. Because you work on a representation of that file, your changes will not be written to the corresponding file unless you instruct Vim to do so with <code>:write</code> or <code>:update</code>.</p>
</div>
<div class="paragraph">
<p>As Vim&#8217;s core file proxies, buffers are (or should be) at the core of your workflow and you owe it to yourself to know how to work with them to achieve reasonable efficiency.</p>
</div>
<div class="sect2">
<h3 id="_the_buffer_list">The buffer list</h3>
<div class="paragraph">
<p>Every buffer created in Vim via <code>:edit</code>, <code>:find</code>, <code>:args</code>, any of their relatives or simply <code>$ vim filename</code> is added to the <em>buffer list</em> where it is assigned a number that will never change until it is explicitely wiped out from the list. Beside that number, a buffer associated with a file will be named after that file, giving us a second way to address that buffer.</p>
</div>
<div class="paragraph">
<p>A typical Vim session could be short and only consist of editing a single file&#8201;&#8212;&#8201;and thus a single buffer&#8201;&#8212;&#8201;or it could go for weeks and consist of dozens and dozens of buffers. Keeping track of so many buffers would be daunting if Vim didn&#8217;t gave us not one, not two, but <em>three</em> commands for listing buffers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:buffers
:files
:ls</pre>
</div>
</div>
<div class="paragraph">
<p>All those commands do the same thing so we will simply use the shortest: <code>:ls</code>. Here is what its output looks like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  1  h   "foo.txt"                      line 1
  2 #h   "bar.txt"                      line 1
  3 %a   "baz.txt"                      line 1
Press ENTER or type command to continue</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The first column shows the buffer number.</p>
</li>
<li>
<p>The second column gives us information on the state of the buffer, <code>h</code> means &#8220;hidden&#8221;, <code>a</code> means &#8220;active&#8221;, <code>%</code> marks the current buffer and <code>#</code> marks the &#8220;alternate file&#8221;, which I usually think of as &#8220;previous buffer&#8221;.</p>
</li>
<li>
<p>The third column tells us the buffer name.</p>
</li>
<li>
<p>And the last column shows the current position of the cursor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No cursor, no active line, no selectionâ€¦ obviously, this list is not nicely interactive so what good is it? Well, the last line gives us a couple of hints: pressing <code>ENTER</code> unsurprisingly makes the list go away but we can also press <code>:</code> to enter command-line mode and use an Ex command to do something with the info we get from the list.</p>
</div>
<div class="paragraph">
<p>Buffers come with <em>a lot</em> of navigation and management commands, let&#8217;s see a few things we can do with the list above:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:b1      " jump to buffer number 1
:b#      " jump back to the previous buffer
:bd 2    " delete buffer number 2</pre>
</div>
</div>
<div class="paragraph">
<p>Unlike some other more &#8220;modern&#8221; editors, Vim doesn&#8217;t have a built-in way of displaying a permanent list of loaded buffers. This may feel like a limitation if you are used to that feature but think about it for a moment&#8230;&#8203; do you <em>really</em> need that list when you are not trying to jump to another buffer?</p>
</div>
<div class="paragraph">
<p>Of course, it is not necessary to do <code>:ls</code> before doing <code>:b24</code> but who wants to keep a list of buffers updated in his head? Well&#8230;&#8203; I certainly don&#8217;t.</p>
</div>
<div class="paragraph">
<p>One way to avoid thinking too much about your buffers is to mash <code>:bn[ext]</code> and <code>:bp[revious]</code> until you get where you want. Your destination might be sixteen buffers away, though, so cycling is not a silver bullet.</p>
</div>
<div class="paragraph">
<p>But that boring <code>:ls</code>, then <code>&lt;CR&gt;</code>, then <code>:b</code>, then <code>24</code>, then <code>&lt;CR&gt;</code>, routine looks like a good candidate for a custom mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap &lt;leader&gt;b :ls&lt;CR&gt;:b</pre>
</div>
</div>
<div class="paragraph">
<p>Here is how it looks:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_buffers">Working with buffers</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_windows">Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(intro)</p>
</div>
<div class="sect2">
<h3 id="_the_life_cycle_of_a_window">The life cycle of a window</h3>

</div>
<div class="sect2">
<h3 id="_working_with_windows">Working with windows</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_tab_pages">Tab pages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(intro)</p>
</div>
<div class="sect2">
<h3 id="_the_life_cycle_of_a_tab_page">The life cycle of a tab page</h3>

</div>
<div class="sect2">
<h3 id="_working_with_tab_pages">Working with tab pages</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_special_windows">Special Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(intro)</p>
</div>
<div class="sect2">
<h3 id="_the_quickfix_window">The quickfix window</h3>
<div class="paragraph">
<p>The quickfix is a handy list that we can populate and navigate at will. It actually is a bit more complicated but the quickfix list can be thought of as a list containing a number of entries made of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a filename,</p>
</li>
<li>
<p>a line number,</p>
</li>
<li>
<p>an optional column number,</p>
</li>
<li>
<p>some text associated with the current item.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That list is global. This means that you can&#8217;t have more than one active list at a time. One could recall previous lists with <code>:colder</code> but I honestly never had to so&#8230;&#8203; YMMV.</p>
</div>
<div class="paragraph">
<p>Vim comes with a bunch of commands that populate the quickfix list like <code>:grep</code> or <code>:vimgrep</code>, used for searching text in your project, and <code>:make</code>, used to build your program or pass them through a syntax checker. Once the quickfix is populated with valid entries, one can use a number of relatively intitively named commands to navigate the list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cfirst
:clast
:cnext
:cprevious</pre>
</div>
</div>
<div class="paragraph">
<p>or use <code>:copen</code>&#8201;&#8212;&#8201;or the slightly smarter <code>:cwindow</code>&#8201;&#8212;&#8201;to open the interactive &#8220;quickfix window&#8221;:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>See? The quickfix window is super-useful and super-easy to use.</p>
</div>
<div class="paragraph">
<p>The quickfix list has a close cousin called &#8220;location list&#8221; that pretty much works the same way except for these two differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>unlike the quickfix list, the location list is local to a window so you can have as many as you have windows,</p>
</li>
<li>
<p>the commands start with an <code>l</code> instead of a <code>c</code>, <code>:lfirst</code>, <code>:lwindow</code>, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using the location list can be useful if you are heavily into windows and tab pages but the quickfix list is probably a simpler choice otherwise.</p>
</div>
<div class="paragraph">
<p>Now, repeating the <code>:w</code> &amp; <code>:mak</code> &amp; <code>:cw</code> dance over and over doesn&#8217;t sound fun. Does it? Well, those commands can be chained with a <code>|</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:w|mak|cw</pre>
</div>
</div>
<div class="paragraph">
<p>and recalled with <code>&lt;Up&gt;</code> so that&#8217;s not big of a deal but there is still room for improvement, here, because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we have too many <code>&lt;Enter&gt;</code> to press,</p>
</li>
<li>
<p>some kind of automation would be better.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s address the first issue by telling Vim to shut up with the <code>:silent</code> command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:w|silent mak|cw</pre>
</div>
</div>
<div class="paragraph">
<p>And take advantage of a great feature called &#8220;autocommands&#8221; for&#8230;&#8203; the automation part.</p>
</div>
<div class="paragraph">
<p>Autocommands are Vim&#8217;s way of executing arbitrary commands when specific events happen. Entering a window, quitting insert mode, loading a buffer with a specific filetype are some of the many events available.</p>
</div>
<div class="paragraph">
<p>An autocommand usually looks like that:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>autocmd event pattern command</pre>
</div>
</div>
<div class="paragraph">
<p>where <code>autocmd</code> is the command that defines an autocommand, <code>event</code> can be a single event or a comma-separated list of events, <code>pattern</code> is a simple pattern describing what [todo] and <code>command</code> is what we want to happen.</p>
</div>
<div class="paragraph">
<p>Scrolling through the list at <code>:help autocommand-events</code> we find <code>BufWritePost</code> which looks like it can be used after <code>:w</code> to <code>:make</code> and <code>:cwindow</code>. Let&#8217;s try it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>autocmd BufWritePost *.c silent make|cwindow</pre>
</div>
</div>
<div class="paragraph">
<p>Phew! That was easy&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_reference">Reference</h4>

</div>
</div>
<div class="sect2">
<h3 id="_the_preview_window">The preview window</h3>

</div>
<div class="sect2">
<h3 id="_the_command_line_window">The Command-line window</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_various_ui_elements">Various UI elements</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_tabline">The tabline</h3>

</div>
<div class="sect2">
<h3 id="_the_statusline">The statusline</h3>

</div>
<div class="sect2">
<h3 id="_line_numbers">Line numbers</h3>

</div>
<div class="sect2">
<h3 id="_the_foldcolumn">The foldcolumn</h3>

</div>
<div class="sect2">
<h3 id="_the_signcolumn">The signcolumn</h3>

</div>
<div class="sect2">
<h3 id="_the_completion_menu">The completion menu</h3>

</div>
<div class="sect2">
<h3 id="_the_command_line">The command-line</h3>

</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-03-29 00:47:19 CET
</div>
</div>
</body>
</html>