<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Your screen</title>
<link rel="stylesheet" href="css/style2.css">
</head>
<body class="article">
<div id="header">
<h1>Your screen</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Vim&#8217;s screen <strong>always</strong> contains <em>at least</em> the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a tab page, always containing at least&#8230;&#8203;</p>
</li>
<li>
<p>a window, always displaying&#8230;&#8203;</p>
</li>
<li>
<p>a buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It may have a number of secondary UI elements such as a &#8220;tabline&#8221; or line numbers, though. The purpose of this chapter is to help you feel at home within that environment.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buffers">Buffers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like Word or Photoshop, Vim lets us create, delete and&#8201;&#8212;&#8201;of course&#8201;&#8212;&#8201;edit &#8220;documents&#8221;, whether they are associated to an actual file or not. Those documents are called &#8220;buffers&#8221;.</p>
</div>
<div class="paragraph">
<p>A buffer is the internal representation of the content of a file. Because you work on a representation of that file, your changes will not be written to disk unless you instruct Vim to do so.</p>
</div>
<div class="paragraph">
<p>As Vim&#8217;s core file proxies, buffers are (or should be) at the core of your workflow and you owe it to yourself to know how to work with them to achieve reasonable efficiency.</p>
</div>
<div class="sect2">
<h3 id="_working_with_buffers">Working with buffers</h3>
<div class="paragraph">
<p>Every buffer created in Vim via <code>:edit</code>, <code>:find</code>, <code>:args</code>, or any of their relatives, or simply <code>$ vim filename</code>, is added to the <em>buffer list</em> where it is assigned a number that will <strong>never</strong> change until it is explicitely wiped out from the list. When started without arguments, Vim will create an empty buffer by default so there&#8217;s really always <em>at least</em> one buffer to work with.</p>
</div>
<div class="paragraph">
<p>Beside that number, buffers are named after the file they are associated with. This gives us two ways to address a buffer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by its number,</p>
</li>
<li>
<p>by its name.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A typical Vim session could be short and only consist of editing a single file&#8201;&#8212;&#8201;and thus a single buffer&#8201;&#8212;&#8201;or it could go for weeks and consist of dozens and dozens of buffers. Keeping track of so many buffers would be daunting if Vim didn&#8217;t gave us not one, not two, but <em>three</em> commands for listing buffers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:buffers
:files
:ls</pre>
</div>
</div>
<div class="paragraph">
<p>All those commands do the same thing so we will simply use the shortest: <code>:ls</code>. Here is what its output looks like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  1  h   "foo.txt"                      line 1
  2 #h   "bar.txt"                      line 1
  3 %a   "baz.txt"                      line 1
Press ENTER or type command to continue</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The first column shows the buffer number.</p>
</li>
<li>
<p>The second column gives us information on the state of the buffer, <code>h</code> means &#8220;hidden&#8221;, <code>a</code> means &#8220;active&#8221;, <code>%</code> marks the current buffer and <code>#</code> marks the &#8220;alternate file&#8221;, which I usually think of as &#8220;previous buffer&#8221;.</p>
</li>
<li>
<p>The third column tells us the buffer name.</p>
</li>
<li>
<p>And the last column shows the current position of the cursor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No cursor, no active line, no selectionâ€¦ obviously, this list is not nicely interactive so what good is it? Well, the last line gives us a couple of hints: pressing <code>ENTER</code> unsurprisingly makes the list go away but we can also press <code>:</code> to enter command-line mode and use an Ex command to do something with the info we get from the list.</p>
</div>
<div class="paragraph">
<p>Buffers come with <em>a lot</em> of navigation and management commands, let&#8217;s see a few things we can do with the list above:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:b1      " jump to buffer number 1
:b#      " jump back to the previous buffer
:bd 2    " delete buffer number 2</pre>
</div>
</div>
<div class="paragraph">
<p>Unlike some other more &#8220;modern&#8221; editors, Vim doesn&#8217;t have a built-in way of displaying a permanent list of loaded buffers. This may feel like a limitation if you are used to that feature but think about it for a moment&#8230;&#8203; do you <em>really</em> need that list when you are not trying to jump to another buffer?</p>
</div>
<div class="paragraph">
<p>Of course, it is not necessary to do <code>:ls</code> before doing <code>:b24</code> but who wants to keep a list of buffers updated in his head? Well&#8230;&#8203; I certainly don&#8217;t.</p>
</div>
<div class="paragraph">
<p>One way to avoid thinking too much about your buffers is to mash <code>:bn[ext]</code> and <code>:bp[revious]</code> until you get where you want. Your destination might be sixteen buffers away, though, so cycling is not a silver bullet.</p>
</div>
<div class="paragraph">
<p>But that boring <code>:ls</code>, then <code>&lt;CR&gt;</code>, then <code>:b</code>, then <code>24</code>, then <code>&lt;CR&gt;</code> routine looks like a good candidate for a nice, mnemonic, custom mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" g-o to b-uffer
nnoremap gb :ls&lt;CR&gt;:b</pre>
</div>
</div>
<div class="paragraph">
<p>Here is how it looks:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>Not bad at all! But there&#8217;s one problem with numbers, though: the file-number mapping is not very intuitive and can be very hard to follow and forces us to pull up a list if we want to go that way.</p>
</div>
<div class="paragraph">
<p>Humans being humans, we are naturally better at names than numbers so the second way to address buffers, <strong>names,</strong> may have a lot of potential. The commands we used before&#8201;&#8212;&#8201;<code>:b</code>, <code>:bd</code>&#8201;&#8212;&#8201;can take &#8220;completable&#8221; partial names as argument which makes it easy and very close to frictionless to switch to a buffer, especially with the wildmenu:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>Again, we can create a convenient mapping to save a bunch of keystrokes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap &lt;leader&gt;b :buffer *</pre>
</div>
</div>
<div class="paragraph">
<p>I hope you noticed the similarity with the <code>&lt;leader&gt;f</code> mapping we added to our <code>vimrc</code> in the previous chapter. We have two commands with a similar purpose that work exactly the same way and follow the same naming pattern:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>f</code> for &#8220;file&#8221;,</p>
</li>
<li>
<p><code>b</code> for &#8220;buffer&#8221;.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_reference">Reference</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_windows">Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just like you always have <em>at least</em> one buffer, that buffer is always displayed in <em>at least</em> one window but Vim gives us the ability to split our workspace in multiple windows&#8201;&#8212;&#8201;often called &#8220;splits&#8221;&#8201;&#8212;&#8201;to display different buffers or parts of a buffer.</p>
</div>
<div class="paragraph">
<p>The exact mechanism is quite simple: the current window is split in two equal parts along the desired axis, <em>vertical</em> or <em>horizontal</em>, and the cursor is placed in the new window. By default, the splitting is done to the left, which can be quite counter-intuitive.</p>
</div>
<div class="sect2">
<h3 id="_working_with_windows">Working with windows</h3>
<div class="paragraph">
<p>The purpose of a window is thus to provide a view into a buffer. It can be created, moved around and closed but it is important to remember that windows and buffers are <strong>totally</strong> separated.</p>
</div>
<div class="paragraph">
<p>If buffers and windows had a one-to-one relationship, listing windows would make just as much sense as listing buffers for navigation purpose. Addressing them by name would certainly be useful too. But they don&#8217;t and</p>
</div>
</div>
<div class="sect2">
<h3 id="_reference_2">Reference</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_tab_pages">Tab pages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Tab pages&#8201;&#8212;&#8201;too often referred to as &#8220;tabs&#8221;&#8201;&#8212;&#8201;have been a neverending source of confusion since their appearance in Vim 7.x. Despite their name and how the <a href="#_the_tabline">&#8220;tabline&#8221;</a> is implemented, Vim&#8217;s <em>tab pages</em> are not like other editor&#8217;s <em>tabs</em>.</p>
</div>
<div class="paragraph">
<p>In other editors, &#8220;tabs&#8221; serve as a proxies for documents. This means that the editor&#8217;s &#8220;tabline&#8221;&#8201;&#8212;&#8201;a list of tabs&#8201;&#8212;&#8201;is effectively a list of documents that is used to navigate from one tab to another and thus from one document to another. A &#8220;tab&#8221; <em>is</em> for all intent and purpose a <em>document</em> and there is no need to separate the tab <em>widget</em> from the document it is associated to.</p>
</div>
<div class="paragraph">
<p>Switching to a &#8220;tab&#8221; is exactly like switching to a document.</p>
</div>
<div class="paragraph">
<p>In Vim, &#8220;tab pages&#8221; are <em>workspaces</em>, associated with &#8220;tab&#8221; widgets, themselves listed in a &#8220;tabline&#8221;. The &#8220;tab&#8221; and &#8220;tabline&#8221; widgets work just like their counterparts in other editors but the <em>huge</em> difference lies in the <em>workspace</em> bit.</p>
</div>
<div class="paragraph">
<p>A workspace is a place where you arrange one or more windows displaying one or more buffers. But we have seen earlier that buffers are <em>global</em> so, while it is entirely possible to have a single buffer displayed in a single window in a single tab page, it is impossible to have a one-to-one relationship between that buffer and that tab page without devising our own buffer/window/tab management paradigm.</p>
</div>
<div class="paragraph">
<p>Because &#8220;tab&#8221; widgets are not associated with specific buffers/files we simply can&#8217;t use them as document proxies.</p>
</div>
<div class="paragraph">
<p>As collections of windows, tab pages offer a pretty good way to manage workspaces. They are ideal for scenarios where we need to have multiple pairs of files displayed side-by-side, or where we suddenly need to open a file from outside the current project&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Just like windows, the place of tab pages in our workflow depends largely on our needs. Using tab pages as file proxies is wrong, but refusing to use them altogether in the name of some imaginary purity is just as wrong. If not <em>more</em>.</p>
</div>
<div class="paragraph">
<p>So&#8230;&#8203; how do we use them?</p>
</div>
<div class="sect2">
<h3 id="_working_with_tab_pages">Working with tab pages</h3>
<div class="paragraph">
<p>Creating a tab page is easy:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tabnew            " creates a new tab page containing one window
                   " displaying a new, unnamed, empty buffer.
:tabe[dit] file    " creates a new tab page containing one window
                   " displaying a buffer associated with 'file'.
:tabf[ind] file    " works similarly as the previous one but uses
                   " ':find' instead of ':edit'.</pre>
</div>
</div>
<div class="paragraph">
<p>The commands above can&#8217;t be easily shortened so one could very well create custom mappings along the same line as the ones we created earlier:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap &lt;leader&gt;tn :tabnew&lt;CR&gt;
nnoremap &lt;leader&gt;te :tabedit **/*
nnoremap &lt;leader&gt;tf :tabfind *</pre>
</div>
</div>
<div class="paragraph">
<p>Closing a tab page is just as easy:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tabc[lose]      " closes the current tab page,
:tabc[lose] 3    " closes tab page number 3,
:tabo[nly]       " closes all tab pages except the current one.</pre>
</div>
</div>
<div class="paragraph">
<p>Note that closing a tab page also closes its windows but <em>it doesn&#8217;t delete the buffers currently displayed in those windows.</em> Remember : windows are <em>views</em> and tab pages are <em>assemblages</em> of windows.</p>
</div>
<div class="paragraph">
<p>Switching to another tab page is also well covered and pretty intuitive:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:tabfir[st]
:tabn[ext]
:tabp[revious]
:tabl[ast]</pre>
</div>
</div>
<div class="paragraph">
<p>In normal mode, <code>gt</code> is the equivalent of <code>:tabnext</code> and <code>gT</code> is the equivalent of <code>:tabprevious</code>.</p>
</div>
<div class="paragraph">
<p>Here are a few example usages:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(pic)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(pic)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(pic)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>Like with buffers and windows, it is also possible to execute a command in each tab page: <code>:tabdo command</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reference_3">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help tab-page</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_special_windows">Special Windows</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Beyond the &#8220;normal&#8221; windows described above, Vim uses a number of very useful specialized windows.</p>
</div>
<div class="sect2">
<h3 id="_the_quickfix_window">The quickfix window</h3>
<div class="paragraph">
<p>The quickfix is a handy list that we can populate and navigate at will. It actually is a bit more complicated but the quickfix list can be thought of as a list containing a number of entries made of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a filename,</p>
</li>
<li>
<p>a line number,</p>
</li>
<li>
<p>an optional column number,</p>
</li>
<li>
<p>some text associated with the current item.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That list is global. This means that you can&#8217;t have more than one active list at a time. One could recall previous lists with <code>:colder</code>, though, but I honestly never had to&#8230;&#8203; so YMMV.</p>
</div>
<div class="paragraph">
<p>Vim comes with a lot of commands that populate the quickfix list, like <code>:grep</code> or <code>:vimgrep</code>, used for searching text in your project, and <code>:make</code>, used to build your program or pass them through a syntax checker. Once the quickfix is populated with valid entries, one can use a number of relatively intuitively named commands to navigate the list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:cfirst
:clast
:cnext
:cprevious</pre>
</div>
</div>
<div class="paragraph">
<p>or use <code>:copen</code> to open the interactive &#8220;quickfix window&#8221;, or&#8201;&#8212;&#8201;even better&#8201;&#8212;&#8201;<code>:cwindow</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>See? The quickfix window is super-useful and super-easy to use.</p>
</div>
<div class="paragraph">
<p>The quickfix list has a close cousin called &#8220;location list&#8221; that pretty much works the same way except for these two differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>unlike the quickfix list, the location list is local to a window so you can have as many as you have windows,</p>
</li>
<li>
<p>the commands start with an <code>l</code> instead of a <code>c</code>, <code>:lfirst</code>, <code>:lwindow</code>, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using the location list can be useful if you are heavily into windows and tab pages but the quickfix list is probably a simpler choice otherwise.</p>
</div>
<div class="paragraph">
<p>Now, repeating the <code>:w</code> &amp; <code>:mak</code> &amp; <code>:cw</code> dance over and over doesn&#8217;t sound fun. Does it? Well, those commands can be chained with a <code>|</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:w|mak|cw</pre>
</div>
</div>
<div class="paragraph">
<p>and recalled with <code>&lt;Up&gt;</code> so that&#8217;s not such a big deal but there is still room for improvement, here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we have too many <code>&lt;Enter&gt;</code> to press,</p>
</li>
<li>
<p>some kind of automation would be better.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s address the first issue by telling Vim to shut up with the <code>:silent</code> command:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:w|silent mak|cw</pre>
</div>
</div>
<div class="paragraph">
<p>A simple mapping would be a perfect alternative to all that typing. Let&#8217;s try with <code>&lt;F5&gt;</code>, a shortcut often used in IDEs to compile the project, both in insert mode and normal mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inoremap &lt;F5&gt; &lt;Esc&gt;:write|silent make|cwindow&lt;CR&gt;
nnoremap &lt;F5&gt; :write|silent make|cwindow&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Hmm&#8230;&#8203; It looks like Vim doesn&#8217;t like bars in mappings. That&#8217;s understandable, actually: bars are used to separate commands but <code>inoremap &lt;F5&gt; &lt;Esc&gt;:write|silent make|cwindow&lt;CR&gt;</code> is <em>one</em> command and the parts between bars don&#8217;t really make sense on their own. So what can we do? Escape those bars?</p>
</div>
<div class="paragraph">
<p>Well yes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inoremap &lt;F5&gt; &lt;Esc&gt;:write\|silent make\|cwindow&lt;CR&gt;
nnoremap &lt;F5&gt; :write\|silent make\|cwindow&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>or we can use <code>&lt;Bar&gt;</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inoremap &lt;F5&gt; &lt;Esc&gt;:write&lt;Bar&gt;silent make&lt;Bar&gt;cwindow&lt;CR&gt;
nnoremap &lt;F5&gt; :write&lt;Bar&gt;silent make&lt;Bar&gt;cwindow&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s see how it looks:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_reference_4">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help quickfix
:help :silent
:help map_bar</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_preview_window">The preview window</h3>
<div class="paragraph">
<p>The preview window is a small window used to preview something, usually the signature of a function while we are working on its usage. It is a lot like a normal window except for these differences:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>opening the preview window doesn&#8217;t steal the focus from the current window,</p>
</li>
<li>
<p>there is only one preview window per tab page,</p>
</li>
<li>
<p>it can be closed even if it is not focused.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This window can be opened with a bunch of commands, among which these ones:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:ptag foo       " open tag 'foo' in a preview window
&lt;C-w&gt;}          " open tag under the cursor in a preview window
:psearch bar    " use include search to find 'bar' and open it in a preview window</pre>
</div>
</div>
<div class="paragraph">
<p>And closed with: <code>:pclose</code> or <code>&lt;C-w&gt;z</code>.</p>
</div>
<div class="paragraph">
<p>Here is the preview window in action:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="sect3">
<h4 id="_reference_5">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help preview-window</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_command_line_window">The Command-line window</h3>
<div class="paragraph">
<p>The command-line is a handy way to input commands but it is not that good when it comes to editing the current command or recalling an old one and changing its parameters. This is not a design flaw or an implementation issue, though: only sane seperation of concerns that should appeal to anyone used to the concept of <strong>modal editing</strong>.</p>
</div>
<div class="paragraph">
<p>You use insert mode to insert text and normal mode to edit text.</p>
</div>
<div class="paragraph">
<p>You use command-line mode to issue commands and the command-line window to edit the current command and command history.</p>
</div>
<div class="paragraph">
<p>Simple.</p>
</div>
<div class="paragraph">
<p>Opening the command-line window from the current command-line mode is done with <code>&lt;C-f&gt;</code>. This will open the relevant command history in the command-line window, with the current command ready for you to edit on the last line.</p>
</div>
<div class="paragraph">
<p>From normal mode, you can use <code>q:</code> to open the command-line history or <code>q/</code>/<code>q?</code> to open the search history, with the cursor in an empty line. Press <code>&lt;CR&gt;</code> in normal mode to run the current command or <code>:q</code> to quit that window.</p>
</div>
<div class="paragraph">
<p>Here is the command-line window in action:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(gifcast)</pre>
</div>
</div>
<div class="paragraph">
<p>Some hardcore Ex commands users like to use the command-line window instead of the usual command-line. This can be done by overriding <code>:</code> in normal mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap : q:i</pre>
</div>
</div>
<div class="paragraph">
<p>I don&#8217;t recommend doing that, actually, but I think it is an interesting example of customization.</p>
</div>
<div class="sect3">
<h4 id="_reference_6">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:h cmdline-window</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_various_ui_elements">Various UI elements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to windows, we have many UI elements at our disposal for displaying information and/or interacting with one feature or another.</p>
</div>
<div class="sect2">
<h3 id="_the_tabline">The tabline</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The tabline is a list of "tabs" working as proxies for tab pages. Each tab shows some information on its associated tab page:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the name of the buffer currently displayed in the currently focused window,</p>
</li>
<li>
<p>the number of windows contained in the tab page when there is more than one,</p>
</li>
<li>
<p>a <code>+</code> if one of the buffers displayed in one of the windows is "dirty".</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you have enabled mouse support in your <code>vimrc</code> and your terminal emulator supports that feature, you can use your mouse to switch to a tab page, reorder the tabs or close the current tab page by clicking on the <code>X</code> at the end of the tabline.</p>
</div>
<div class="paragraph">
<p>When to show a tabline can be defined with the <code>showtabline</code> option and what information to display depends on the <code>tabline</code> option.</p>
</div>
<div class="paragraph">
<p>While Vim&#8217;s <em>tab pages</em> are definitely not equivalent to other editor&#8217;s <em>tabs</em>, Vim&#8217;s <em>tabline</em> looks and works a lot like its counterparts and suffers from the same usability issues.</p>
</div>
<div class="paragraph">
<p>The main issue is that tabs are used to display filenames and filenames take up a lot of horizontal space. An horizontal space that is physically limited and thus incapable of displaying more than a few tabs. Many solutions exist to remedy that problem: wrapping the tabline to form a second one, adding scrolling widgets at both ends of the tabline, grouping tabs, truncating filenames&#8230;&#8203; The harsh reality is that none of those "solutions" is free of annoying side effects which, ultimately, can turn an otherwise good idea into an unusable gyzmo.</p>
</div>
<div class="paragraph">
<p>The tabline and tab pages still have their use, mind you, but it is important to not think about them as you would in other editors.</p>
</div>
<div class="sect3">
<h4 id="_reference_7">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help 'showtabline'
:help 'tabline'
:help setting-tabline</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_statusline">The statusline</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The statusline is that "bar", at the bottom of windows, used to show information on the window itself or the buffer currently displayed in that window. It can also be used to resize windows if mouse support is enabled.</p>
</div>
<div class="paragraph">
<p>By default, the statusline is shown only when there is more than one window but this can be changed with the <code>laststatus</code> option:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set laststatus=2</pre>
</div>
</div>
<div class="paragraph">
<p>The default content of the statusline&#8201;&#8212;&#8201;the filename and a status indicator&#8201;&#8212;&#8201;is not exactly thrilling but it&#8217;s possible to beef it up by enabling the <code>ruler</code> option that shows the line and colum of the cursor and tells how much of the buffer is currently visible.</p>
</div>
<div class="paragraph">
<p>It is very common, though, to customize it a bit further by playing with the <code>statusline</code> option that gives more control over the statusline&#8217;s content and appearance.</p>
</div>
<div class="paragraph">
<p>This is how I define the statusline shown in the picture above, the explanation for each item can be found in <code>:help 'statusline'</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set statusline=%&lt;\ %f\ %m%r%y%w%=\ L:\ \%l\/\%L\ C:\ \%c\</pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to define colors for specific parts or use functions to display dynamic information not provided by Vim but I recommend measure, here: the statusline is an information device, not a decorative widget.</p>
</div>
<div class="sect3">
<h4 id="_reference_8">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help 'laststatus'
:help 'ruler'
:help 'statusline'</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_line_numbers">Line numbers</h3>
<div class="paragraph">
<p>Line numbers are a fairly straightforward feature that doesn&#8217;t deserve much explanation. One enables it with <code>:set number</code>, disables it with <code>:set nonumber</code> and decides how much room they take with <code>:set numberwidth=6</code>.</p>
</div>
<div class="paragraph">
<p>In most editors or IDEs, line numbers are only used directly by users in two ways: to communicate with other people who work on the same code and to jump to a specific line.</p>
</div>
<div class="paragraph">
<p>In addition, Vim allows us to use line numbers to define the range and/or the address for many Ex commands:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>33G          " go to line 33
V13G         " linewise visual selection from here to line 13
:2t24        " copy line 2 after line 24
:m12         " move current line after line 12
:8,17d       " delete lines 8 to 17
:46put=@f    " put content of register f after line 46</pre>
</div>
</div>
<div class="paragraph">
<p>But we are not limited to absolute line numbers: we can use relative line numbers to see how far a line is from the current line.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(screenshot)</pre>
</div>
</div>
<div class="paragraph">
<p>Relative numbers can be enabled with <code>set relativenumber</code> and used in the same way as absolute line numbers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>6j           " go down 6 lines
V5k          " linewise visual selection from here to 5 lines above
:-2,+6m45    " move lines from 2 lines above to 6 lines below after line 45</pre>
</div>
</div>
<div class="sect3">
<h4 id="_reference_9">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help 'number'
:help 'numberwidth'
:help 'relativenumber'</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_fold_column">The fold column</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>"fold column"</code> is disabled by default but can be enabled by setting the <code>foldcolumn</code> option to a number between 1 and 12. It is used to show information about the folds in your buffer and let you open and close them with the mouse if mouse support is enabled.</p>
</div>
<div class="paragraph">
<p>Open folds are marked with a clickable <code>-</code>, lines belonging to a fold are marked with a <code>|</code> and closed folds are marked with a clickable <code>+</code>.</p>
</div>
<div class="sect3">
<h4 id="_reference_10">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:h fold-foldcolumn
:h 'foldcolumn'</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_sign_column">The sign column</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The "sign column" can&#8217;t be shown or hidden easily: Vim shows it when you have one or more signs in your buffer and removes it when there&#8217;s no sign anymore.</p>
</div>
<div class="paragraph">
<p>The color and content of individual signs is usually defined by plugin authors whereas the background of the column is the responsibility of your colorscheme.</p>
</div>
<div class="sect3">
<h4 id="_reference_11">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help signs</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_completion_menu">The completion menu</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The completion menu comes up when you press one of the many key-combinations affected to insert mode completion and there is at least one or more possible completions. In pure "modal" fashion, once the menu is displayed, some keys acquire a new meaning to allow cursor movement and selection but the general pattern stays consistent with the general Vim UI and works more or less how we expect.</p>
</div>
<div class="paragraph">
<p>problems and solutions (to be written)</p>
</div>
<div class="sect3">
<h4 id="_reference_12">Reference</h4>
<div class="literalblock">
<div class="content">
<pre>:help ins-completion-menu</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_command_line">The command-line</h3>
<div class="literalblock">
<div class="content">
<pre>(picture)</pre>
</div>
</div>
<div class="paragraph">
<p>The command-line is Vim&#8217;s main interface. Like the prompt of your computer&#8217;s shell, it is used to send commands to Vim and for feedback if necessary.</p>
</div>
<div class="sect3">
<h4 id="_reference_13">Reference</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(to be written)</p>
</div>
<div id="front">
    <a href="#" id="open-close">...</a>
    <ul>
        <li>
            <a href="0.html">0&nbsp;&nbsp;&nbsp;An introduction</a>
        </li>
        <li>
            <a href="1.html">1&nbsp;&nbsp;&nbsp;Lord of the files</a>
        </li>
        <li class="current">
            <a href="2.html">2&nbsp;&nbsp;&nbsp;Your workspace</a>
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_buffers">Buffers</a>
<ul class="sectlevel2">
<li><a href="#_working_with_buffers">Working with buffers</a></li>
<li><a href="#_reference">Reference</a></li>
</ul>
</li>
<li><a href="#_windows">Windows</a>
<ul class="sectlevel2">
<li><a href="#_working_with_windows">Working with windows</a></li>
<li><a href="#_reference_2">Reference</a></li>
</ul>
</li>
<li><a href="#_tab_pages">Tab pages</a>
<ul class="sectlevel2">
<li><a href="#_working_with_tab_pages">Working with tab pages</a></li>
<li><a href="#_reference_3">Reference</a></li>
</ul>
</li>
<li><a href="#_special_windows">Special Windows</a>
<ul class="sectlevel2">
<li><a href="#_the_quickfix_window">The quickfix window</a></li>
<li><a href="#_the_preview_window">The preview window</a></li>
<li><a href="#_the_command_line_window">The Command-line window</a></li>
</ul>
</li>
<li><a href="#_various_ui_elements">Various UI elements</a>
<ul class="sectlevel2">
<li><a href="#_the_tabline">The tabline</a></li>
<li><a href="#_the_statusline">The statusline</a></li>
<li><a href="#_line_numbers">Line numbers</a></li>
<li><a href="#_the_fold_column">The fold column</a></li>
<li><a href="#_the_sign_column">The sign column</a></li>
<li><a href="#_the_completion_menu">The completion menu</a></li>
<li><a href="#_the_command_line">The command-line</a></li>
</ul>
</li>
<li><a href="#_conclusion">Conclusion</a></li>
</ul>
</div>
        </li>
        <li>
            <a href="3.html">3&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="4.html">4&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="5.html">5&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="6.html">6&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="7.html">7&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="8.html">8&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
    </ul>
</div>
<h6>The Patient Vimmer</h6>
<div id="bottom">
    <p>Written by <a href="https://github.com/romainl">Romain Lafourcade</a>, with help from <a href="https://github.com/dahu/">Barry Arthur</a> and the #vim community.</p>
<p>Copyleft 2015</p>
</div>
<script src="javascript/behavior.js"></script>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-06-12 11:21:18 CEST
</div>
</div>
</body>
</html>