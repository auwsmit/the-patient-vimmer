<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<title>Lord of the files</title>
<link rel="stylesheet" href="css/style.css">
</head>
<body class="article">
<div id="header">
<h1>Lord of the files</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter explores the many ways to open text files for editing. From outside of Vim and from Vim itself.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_for_argument_s_sake">For argument&#8217;s sake</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Like its distant cousins <code>nano</code> and <code>emacs</code> or, really, most command-line programs, Vim is usually started without arguments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ vim</pre>
</div>
</div>
<div class="paragraph">
<p>or with one or more explicit filename as arguments:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ vim file1 file2 file3</pre>
</div>
</div>
<div class="paragraph">
<p>or with an expression expanded by your shell before passing it to Vim:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ vim *.js</pre>
</div>
</div>
<div class="paragraph">
<p>But, no matter how we start Vim, we might want to edit other files without leaving Vim. How do we do it?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__edit">:edit</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>:edit</code> (shortened to <code>:e</code>) is the canonical way to open a file for editing, whether the file exists on disk or not.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e foo.txt
:e ../bar.txt</pre>
</div>
</div>
<div class="paragraph">
<p>It is important to note that this command only accepts <em>one</em> file name as argument so you can forget these for the time being:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e file1 file2 file3
:e *foo</pre>
</div>
</div>
<div class="paragraph">
<p>It can be done, of course, but with a different command. We will come to that later.</p>
</div>
<div class="paragraph">
<p><code>:e</code> covers a lot of ground already, but we will need fast fingers and a vast memory when time will come to edit files buried at the bottom of a large and complex directory structure.</p>
</div>
<div class="sect2">
<h3 id="_reference">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help :edit</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tab_completion">Tab-completion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fortunately, Vim&#8217;s tab-completion lets us cycle through eligible files:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/1_tab-completion.gif"><img src="images/gifcast_off.png" alt="gifcast off"></a>
</div>
</div>
<div class="paragraph">
<p>Here are a few default bindings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;Tab&gt;</code>     selects the next item,</p>
</li>
<li>
<p><code>&lt;S-Tab&gt;</code>   selects the previous item,</p>
</li>
<li>
<p><code>&lt;Down&gt;</code>    enters a directory,</p>
</li>
<li>
<p><code>&lt;CR&gt;</code>      chooses the selected item,</p>
</li>
<li>
<p><code>&lt;C-d&gt;</code>     lists the completion items.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pretty basic.</p>
</div>
<div class="sect2">
<h3 id="_reference_2">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help cmdline-completion</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_wildmenu">The wildmenu</h2>
<div class="sectionbody">
<div class="paragraph">
<p>But we are in the dark, here: we have no idea how large the completion list is unless we press <code>&lt;C-d&gt;</code> every couple of keystrokes or if and how we could refine our query or how to leave the current directory! <em>Basic</em> tab-completion is better than nothing but meh&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Don&#8217;t worry! Vim has our back with a brilliant feature called &#8220;wildmenu&#8221; that temporarily replaces the status line with a handy menu:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/1_wildmenu.gif"><img src="images/gifcast_off.png" alt="gifcast off"></a>
</div>
</div>
<div class="paragraph">
<p>Navigation is a lot easier now that we have an idea of where we are and what&#8217;s next. It is also easier to traverse directories with the new <code>&lt;Up&gt;</code> binding. You can enable this feature for the current session with:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set wildmenu</pre>
</div>
</div>
<div class="paragraph">
<p>and for every further session by adding this line to your <code>vimrc</code>, as usual:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set wildmenu</pre>
</div>
</div>
<div class="sect2">
<h3 id="_reference_3">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help 'wildmenu'</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wildcards_up_our_sleeve">Wildcards up our sleeve</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most of the time, though, the first two or three letters of a file name may not be enough&#8230;&#8203; or we only remember the end. That&#8217;s where the &#8220;star&#8221; wildcard comes in handy, just like in your shell:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e *fr&lt;Tab&gt;
:e README_fr.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Vim even has a special wildcard called &#8220;starstar&#8221;, that makes it possible to recurse through subdirectories.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e **/*use&lt;Tab&gt;
:e app/controllers/user_management.js</pre>
</div>
</div>
<div class="paragraph">
<p>The main benefits of &#8220;starstar&#8221; are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we are now able to navigate through a flat list instead of a potentially deep hierarchy, saving quite a bunch of keystrokes and brain cells in the process,</p>
</li>
<li>
<p>we can also save large amounts of typing by skipping subdirectories.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/1_wildcards.gif"><img src="images/gifcast_off.png" alt="gifcast off"></a>
</div>
</div>
<div class="sect2">
<h3 id="_reference_4">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help starstar</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mappings">Mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What if we could skip the pretty but too repetitive <code>:e **/*</code> part?</p>
</div>
<div class="paragraph">
<p>&#8220;Macros&#8221; are a core aspect of the Vim experience. The name is most often associated with &#8220;recording&#8221; but they can also be used directly, with <code>:normal</code>, or as part of a mapping. The principle is always the same: we give Vim a bunch of keys to &#8220;press&#8221; very quickly, expecting the same result as if we pressed those keys ourself.</p>
</div>
<div class="paragraph">
<p>Mappings are very important when it comes to customizing Vim, simply because they turn repetitive actions into near-instantaneous magic. Allowing us to save many thousands of keystrokes with minimal configuration.</p>
</div>
<div class="paragraph">
<p>Here is the anatomy of a mapping:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:map key action</pre>
</div>
</div>
<div class="paragraph">
<p>where <code>action</code> is what you want to happen when you press <code>key</code>; it could be a macro, an Ex command, a function call&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The command used to define your mapping can be any of the following:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">recursive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">non-recursive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mode</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>map</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">normal, visual, select, operator-pending</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cnoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">command-line</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>imap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>inoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">insert</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nnoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">normal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>omap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">operator-pending</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>snoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">select</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vnoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">visual, select</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xmap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>xnoremap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">visual</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Try to be as specific as possible.</p>
</div>
<div class="paragraph">
<p>Here are a few examples:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>" press &lt;F5&gt; to add quotes around the word under the cursor in normal mode
:nnoremap &lt;F5&gt; ciw"&lt;C-r&gt;""

" press &lt;F6&gt; to call a function in normal mode
:nnoremap &lt;F6&gt; :call MyFunction()&lt;CR&gt;

" press &lt;F7&gt; to execute a command in normal mode
:nnoremap &lt;F7&gt; :MyCommand&lt;CR&gt;

" press &lt;F8&gt; to filter the current visual selection through 'uniq'
:xnoremap &lt;F8&gt; !uniq&lt;CR&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say we want Vim to type <code>:e **/*</code> for us when we press <code>&lt;F6&gt;</code> in <em>normal</em> mode:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:nmap &lt;F6&gt; :e **/*</pre>
</div>
</div>
<div class="paragraph">
<p>Easy! We only have to do <code>&lt;F6&gt;foo&lt;Tab&gt;</code> to list every file whose name contains <code>foo</code> under the working directory and every subdirectory. Woohoo!</p>
</div>
<div class="paragraph">
<p>But what&#8217;s the deal with <code>*map</code> and <code>*noremap</code>?</p>
</div>
<div class="paragraph">
<p>It&#8217;s really quite simple&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>nmap key command</code> means that pressing <code>key</code> in normal mode will execute <code>command</code> <em>with its current meaning</em>. This form is <em>only</em> useful when we want to use another mapping in our mapping; it is called &#8220;recursive mapping&#8221;. Example:</p>
<div class="literalblock">
<div class="content">
<pre>:nmap b B        " change 'b' to work like 'B'
:nmap &lt;F5&gt; dB    " '&lt;F5&gt;' works like 'BD', not like 'dB'</pre>
</div>
</div>
</li>
<li>
<p><code>nnoremap key command</code> means that pressing <code>key</code> in normal mode will execute <code>command</code> <em>with its default meaning</em>. This form is usually the one we want, it is called &#8220;non-recursive mapping&#8221;. Example:</p>
<div class="literalblock">
<div class="content">
<pre>:nmap b B            " change 'b' to work like 'B'
:nnoremap &lt;F5&gt; dB    " '&lt;F5&gt;' works like 'bD'</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our mappings <em>have</em> to be solid because they will serve as the foundation of our workflow. Non-recursive mappings are the safest choice:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:nnoremap &lt;F6&gt; :e **/*</pre>
</div>
</div>
<div class="sect2">
<h3 id="_a_leader_worth_following">A leader worth following</h3>
<div class="paragraph">
<p>While the whole purpose of the <code>&lt;Fn&gt;</code> keys is to be &#8220;programmed&#8221; to do whatever specific <em>function</em> the user needs, they don&#8217;t fit very well with Vim&#8217;s other highly mnemonic bindings so it is wiser to use a key that &#8220;maps&#8221; to the idea of <em>editing</em>. But we have a problem: Vim already uses most&#8201;&#8212;&#8201;if not all&#8201;&#8212;&#8201;of the freaking keys on our keyboard!</p>
</div>
<div class="paragraph">
<p>The &#8220;leader&#8221; mechanism allows us to define a <code>&lt;leader&gt;</code> key (<code>\</code> by default) that will work as a mini-mode or namespace for our custom mappings. <code>:help mapleader</code> gives us the following example :</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:let mapleader = ","</pre>
</div>
</div>
<div class="paragraph">
<p>which allows us to use the comma as <code>&lt;leader&gt;</code> in all our mappings:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:nnoremap &lt;leader&gt;e :edit **/*</pre>
</div>
</div>
<div class="paragraph">
<p>We are of course free to choose which key to use as our leader. <code>&lt;Space&gt;</code>, for example, can be a more sensible choice because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>,</code> is a very useful key (repeat last <code>fFtT</code> in the other direction) with no alternative,</p>
</li>
<li>
<p><code>&lt;Space&gt;</code> is synonymous with <code>l</code> and <code>&lt;Right&gt;</code> so it can safely be remapped.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s end this section by adding these lines to our <code>vimrc</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>let mapleader = "\&lt;Space&gt;"
nnoremap &lt;leader&gt;e :edit **/*</pre>
</div>
</div>
<div class="paragraph">
<p>and try them out after sourcing our <code>vimrc</code> again:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="images/1_leader-e.gif"><img src="images/gifcast_off.png" alt="gifcast off"></a>
</div>
</div>
<div class="paragraph">
<p>Neat!</p>
</div>
</div>
<div class="sect2">
<h3 id="_reference_5">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help mapping
:help mapleader</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__find">:find</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vim comes with an often overlooked command fittingly named <code>:find</code> that differs from <code>:edit</code> in one big way: <strong>it can be set to visit specific directories.</strong></p>
</div>
<div class="paragraph">
<p>The key to using <code>:find</code> efficiently is to define a good value for the <code>path</code> option that tells Vim where to <em>find</em> files. The default value may be a good starting point for C programmers but we can set it to a more generic&#8201;&#8212;&#8201;and simplistic&#8201;&#8212;&#8201;value:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path=.,**</pre>
</div>
</div>
<div class="paragraph">
<p>which allows us to find files in the directory of the current file <em>and</em> anywhere under the working directory, recursively, without needing to use <code>**</code> explicitly.</p>
</div>
<div class="paragraph">
<p>Or we can use a more project-specific value:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:set path=app/views/**,app/controllers/**</pre>
</div>
</div>
<div class="paragraph">
<p>The sky is still the limit&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>We can now use the <code>:find</code> command as a smarter replacement for <code>:edit</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:find foo&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>versus:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e **/foo&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>:edit</code>, <code>:find</code> does its completion from the start of the file name so <code>:find foo</code> will match <code>foobar.txt</code> but not <code>model_foo.txt</code>. Add a wildcard for an even more useful completion:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:find *foo&lt;Tab&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(screencast)</pre>
</div>
</div>
<div class="sect2">
<h3 id="_reference_6">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help :find
:help 'path'</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_more_mappings">More mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Again, we can go a bit further with a nice <em>normal</em> mode mapping similar to the one we devised earlier for <code>:edit</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:nnoremap &lt;leader&gt;f :find *</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(screencast)</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s replace the <code>:edit</code>-based mapping in our <code>vimrc</code> with the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>nnoremap &lt;leader&gt;f :find *
set path=.,**</pre>
</div>
</div>
<div class="paragraph">
<p>and move on to the next section&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_customizing_file_name_completion_and_the_wildmenu">Customizing file name completion and the &#8220;wildmenu&#8221;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can further customize the behavior of Vim&#8217;s file name completion with a bunch of options that work for <code>:edit</code> <em>and</em> <code>:find</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:help wildmode        " defines the behavior of the wildmenu
:help wildignore      " tells Vim to ignore some patterns
:help wildignorecase  " enables case insensitivity
:help suffixes        " sets pattern-based priority</pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s go through them one by one:</p>
</div>
<div class="sect2">
<h3 id="_wildmode">wildmode</h3>
<div class="paragraph">
<p><code>'wildmode'</code> defines the behavior of the wildmenu. You can tell Vim to show a list of completions or not but also when to show it. It is recommended to play with the many possible combinations until you find the right one.</p>
</div>
<div class="paragraph">
<p>The default value is <code>full</code></p>
</div>
<div class="paragraph">
<p>here is an example value from my <code>vimrc</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set wildmode=list:full</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wildignore">wildignore</h3>
<div class="paragraph">
<p><code>'wildignore'</code> serves the same purpose as <code>.gitignore</code> and similar configuration files: patterns are used to tell Vim what files/directories to ignore when doing completion. Again, the right values depend on your actual needs.</p>
</div>
<div class="paragraph">
<p>Here is an example value that ignores <code>tags</code> and <code>cscope.out</code> files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set wildignore+=tags,cscope.out</pre>
</div>
</div>
<div class="paragraph">
<p>Note the <code>+=</code> operator that allows us to <em>add</em> new values instead of redefining the whole thing every time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_wildignorecase">wildignorecase</h3>
<div class="paragraph">
<p><code>'wildignorecase'</code> is a more generic variant of <code>'fileignorecase'</code>; it allows this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e read&lt;Tab&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>to yield:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:e README.md</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_suffixes">suffixes</h3>
<div class="paragraph">
<p><code>'suffixes'</code> is a mechanism that allows Vim to give low priority to files matching the defined patterns.</p>
</div>
<div class="paragraph">
<p>Example usage:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>set suffixes+=.foo,.min.bar</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reference_7">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help 'wildmode'
:help 'wildignore'
:help 'wildignorecase'
:help 'suffixes'</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_but_i_em_need_em_a_file_explorer">But I <em>need</em> a file explorer!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes, we just need to find our way in the deep and uncharted waters of a project that was started by the guy whom just left the company. We only have a rough idea of the structure of the project and choosing what to edit on the command-line can be less than fun, even with our shiny mappings.</p>
</div>
<div class="paragraph">
<p>Thankfully, Vim comes with Netrw, a full-featured (some say &#8220;bloated&#8221;) text-based file explorer that allows us to dig down that new project much like we would do in a graphical file explorer:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(screencast)</pre>
</div>
</div>
<div class="paragraph">
<p>Here are a few default bindings for reference:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;cr&gt;</code>   open the file/directory under the cursor,</p>
</li>
<li>
<p><code>-</code>      go up one directory,</p>
</li>
<li>
<p><code>o</code>      open the file/directory under the cursor in a new window,</p>
</li>
<li>
<p><code>P</code>      open the file/directory under the cursor in the previous window,</p>
</li>
<li>
<p><code>t</code>      open the file/directory under the cursor in a new tab page.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the three commands you need to know:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:Ex</code>    open a listing of the current directory,</p>
</li>
<li>
<p><code>:Lex</code>   open a listing of the current directory in a smaller vertical window, similar to the "project" pane common in other editors and IDEs,</p>
</li>
<li>
<p><code>:Rex</code>   come back to the previous listing.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Netrw&#8217;s documentation is massive and covers a lot more than what you probably need for basic exploration and file-handling but you should at least take a look at the following sections&#8230;&#8203;</p>
</div>
<div class="sect2">
<h3 id="_reference_8">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help netrw-browse-maps
:help netrw-quickhelp
:help :Lexplore</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opening_multiple_files">Opening multiple files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As discussed before, it is very common to start Vim with multiple files or an expression expanded to multiple files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ vim file1 file2 file3
$ vim `find . -name '*.txt'`</pre>
</div>
</div>
<div class="paragraph">
<p>The filenames used as arguments when starting Vim are stored in the global <em>argument list</em> which can be manipulated in many ways. In practice, opening multiple files at once from Vim is as simple as replacing the argument list:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:args foo.js foo.html foo.css</pre>
</div>
</div>
<div class="paragraph">
<p>or adding to it:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>:argadd *.py</pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can use <code>:next file file file</code> as an alternative to <code>:args file file file</code></p>
</div>
<div class="sect2">
<h3 id="_reference_9">Reference</h3>
<div class="literalblock">
<div class="content">
<pre>:help buffer-list
:help argument-list
:help :args
:help :argadd
:help :next</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Opening files for editing is neither complex nor hard but&#8201;&#8212;&#8201;as with everything in Vim&#8201;&#8212;&#8201;it can be made quicker and easier with a couple of settings and mappings. Make sure you have exhausted the built-in ways before installing the latest and greatest fuzzy gadget people rave about on Reddit, Twitter or Hacker News.</p>
</div>
<div id="front">
    <h6>The Patient Vimmer</h6>
    <ul>
        <li>
            <a href="0.html">0&nbsp;&nbsp;&nbsp;An introduction</a>
        </li>
        <li class="current">
            <a href="1.html">1&nbsp;&nbsp;&nbsp;Lord of the files</a>
        </li>
        <li>
            <a href="2.html">2&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="3.html">3&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="4.html">4&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="5.html">5&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="6.html">6&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="7.html">7&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="8.html">8&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
    </ul>
    <div id="bottom">
        <p>Written by <a href="https://github.com/romainl">Romain Lafourcade</a>, with help from <a href="https://github.com/dahu/">Barry Arthur</a> and the #vim community.</p>
        <p>Copyleft 2015</p>
    </div>
</div>
<script src="javascript/jquery-1.11.2.min.js"></script>
<script src="javascript/behavior.js"></script>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-03-21 10:52:28 CET
</div>
</div>
</body>
</html>